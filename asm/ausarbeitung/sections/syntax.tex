\section{Syntax}

In der Welt des x86-Assemblers gibt es zwei große Syntaxfamilien: die Intel und
die AT\&T-Syntax. Während Erstere in einer Vielzahl von Assemblern (NASM, TASM,
MASM, YASM, usw.) und Disassemblern (IDA Pro, OllyDbg) zur Standardsyntax zählt
und Intel die x86-Platform damit dokumentiert, ist Letztere dennoch nicht
gänzlich irrelevant. In der UNIX und Linux-Welt wurde lange Zeit nur AT\&T's
Syntaxstil von den ausgelieferten Assemblern \texttt{as} bzw. \texttt{gas}
unterstütlich. Insbesondere durch die Verbreitung der GNU Compiler Collection
hat sich dieser Stil bis heute gehalten, obwohl der GNU Assembler mittlerweile
auch die Intel-Syntax beherscht.

Überhaupt sind die Unterschiede breider Stile gleichmächtig und lassen sich
trotz erheblicher optischer Unterschiede problemlos ineinander konvertieren
(z.B. mit Intel2GAS \cite{i2g}). Für die Folgenden Beispiele wird die
Intel-Syntax als die kanonische Referenz betrachtet und jeweils der
äquivilenten AT\&T-Syntax gegenübergestellt.

% [i2g] http://www.niksula.hut.fi/~mtiihone/intel2gas/

\subsection{Arbeitsweise des Assemblers}

Beim Programmieren mit einem Assembler beschreibt jede Zeile genau eine
Prozessorinstruktion über ihr Symbol, dem sogenannten Mnemonic, gefolgt von
den dazugehörigen optionalen Argumenten. Die Aufgabe des Assemblers ist es nun,
dieses Symbolische Programm direkt in die entsprechende Folge binären
x86-Maschinencode – sogenannte Opcodes, die üblicherweise byteweise,
hexadezimal dargestellt werden – zu übersetzen.

Vereinfacht gesagt bedient sich der Assembler einer großen Symboltabelle in der
für jedes Tupel von Mnemnonic und Argumenten der entsprechende Opcode vermerkt
ist. Der Programmierer könnte zwar auch direkt in Opcodes programmieren bekommt
aber durch den Assembler die Hilfestellung sich Symbole statt hexadezimalen Code
merken zu dürfen.

\subsection{Instruktionen}

Eine Zeile in einem Assemblerprogramm hat folgende Form und ist in beiden
Syntaxstilen gleich:

\texttt{[label:] mnemonic [argument1][, argument2][, argument3]}

Label ist eine Sprungmarke und optional, ebenso wie die Argumente. Deren
erforderliche Anzahl hängt von der Instruktion ab. Maximal drei, häufiger zwei
Argumente sind üblich. Das Mnemnonic bzw. Instruktionssymbol ist eine kurze
Zeichenkette, wie zum Beispiel MOV, ADD oder PUSH, und abstrahiert gleich über
eine Klasse von Opcodes mit derselben Funktion.\cite{intelmanual} So ist zum
Beispiel die Kopieroperation für Argumente verschiedene Art (Register,
Konstanten) immer das Mnemnonic MOV obwohl sich die Opcodes unterscheiden.

Groß- und Kleinschreibung wird nicht unterschieden.

\subsection{Parameter}

Bei vielen Befehlen sind zwei Argumente üblich. Es wird dann meist von Quell-
und Zieloperanden gesprochen (source and destination parameter). Die Semantik
der Parameterreihenfolge bei Intel-Syntax entgegengesetzt zur AT\&-Syntax.

Ein Parameter kann von dreierlei Art sein: ein Register, eine Konstante oder
Speicheradresse. Die Registerbezeichnungen (z.B. EAX, EBP) sind bei Intel und
AT\&T identisch, allerdings erfodert Letztere noch ein Prozentzeichen im
Prefix. Konstanten erhalten bei AT\&T ein Dollarzeichen-Prefix. Intel-Assembler
benötigt diese Kennzeichnung nicht.

\hspace{5mm} \makebox[1.5cm]{Intel: \hfill}
\texttt{mov eax, 5}

Eine weitere Eigenart der AT\&T-Syntax ist ein Suffix für Befehle (siehe
Tabelle~\ref{tab:syntaxdiffs}), der die Parametergröße beschreibt: Byte, Word
(16 Bit), Long oder Double-Word  (32 Bit) bzw.  Quad-Word (64-Bit). Für Intels
Syntax leitet der Assembler den Typ automatisch vom Parameter ab.

\hspace{5mm} \makebox[1.5cm]{AT\&T: \hfill}
\texttt{movl \$5, \%eax}

Ein Parameter kann eine absolute Adresse enthalten oder indirekt auf den Inhalt
einer Speicherstelle zeigen. Die Speicheradresse für die Derefeerenzierung kann
aus einem Ausdruck berechnet werden.  Diese effektive Adresse wird bei Intel
aus Variblen in eckigen Klammern gebildet und kann eine Typangabe wie
\texttt{BYTE},  \texttt{WORD} und \texttt{DWORD} gefolgt von  \texttt{PTR}
(Pointer) vorangestellt bekommen.

\hspace{5mm} \makebox[1.5cm]{Intel: \hfill}
\texttt{mov eax, dword ptr [ebp+4]}

In AT\&T Syntax berechnet sich eine Adresse nach dem sogenannten \emph{base
indexed addressing}-Schema aus den Einzelkomponenten Verschiebung (auch
\emph{displacement}), Basis, Index, Skalierung, wie folgt: $Verschiebung + Basis +
Index*Skalierung$ . Ein Beispiel:

\hspace{5mm} \makebox[1.5cm]{AT\&T: \hfill}
\texttt{movl 4(\%ebp), \%eax}

Die wesentliche Syntax-Unterschiede sind in der Tabelle~\ref{tab:syntaxdiffs}
zusammengefasst.

%\clearpage

\begin{table}[h]	% place here
\begin{tabular}{lll}
\\	                          & INTEL SYNTAX                  & AT\&T SYNTAX
\\\hline
\\	Parameter 								& \tt mnem dest, src, const  	  & \tt mnem src, dest, const
\\  Adressierung  				  	&	\tt [base+index*scale+disp]   & \tt disp(base, index, scale)
\\	Register      						& \tt eax              					& \tt \%eax
\\	Konstante     						& \tt 0xFF             					& \tt \$0xFF
\\	Dereferenzieung   				& \tt [addr]           					& \tt addr(,1)
\\	Absolute Adresse 			 	  & \tt addr             					& \tt *addr
\\	{\tt byte} Instruktion    & \tt mov byte ptr     					& \tt movb
\\	{\tt word} Instruktion    & \tt mov word ptr     					& \tt movw
\\  {\tt dword} Instruktion   & \tt mov dword ptr    					& \tt movl
\end{tabular}
\caption{Syntax Unterschiede} \label{tab:syntaxdiffs}
\end{table}

\subsection{Assembler-Directiven}
Jeder Assembler besitzt einen eigenen Satz an spezifischen Direktiven. Streng
genommen gehören diese nicht zur Syntax, allerdings sind sie nötig um einige
Metainformationen zur Code-Struktur zu definieren. Die Direktiven sind stark
abhängig von der eingesetzten Software (NASM, YASM, GNU as, etc.) und selten
kompatibel zwischen diesen Assembler-Dialekten. Fast immer gibt es aber eine
ähnlich lautende Entsprechung. 

Eine Typische Anweisung ist die Zuordung eines Bezeichners zu einem Code- oder
Datensegment. Die Addressen der Instruktionen werden beim Assemblieren ihrem
Segment zugeordnet. Bei NASM heißt die Direktive \texttt{section}
bei GAS \texttt{.section}. Die Sektionen \texttt{.text} und
\texttt{.data} für das Code- bzw. statische Datensegment sind dabei traditionell
unter Unix-artigen Systemem gebräuchlich. Die Bezeichner können aber 
beliebig gewählt werden.

Oft ist es auch nötig Datenbereiche zu reservieren oder statisch zu
initialisieren, zum Beispiel um feste Strings zu definieren. Dazu dienen
Pseudo-Instructionen wie \texttt{DB, DW, DD}, etc. (\emph{define byte, define
word, define dword}) und \texttt{RESB, RESW, RESQ} (\emph{reserve byte}, usw.)
bei NASM und auch MASM. Die Definition von Konstanten erfolgt mittels
\texttt{EQU}. Diesen Definitionen kann ein Label vorangestellt werden über
welches man die Adresse der jeweiligen Daten im Code referenzieren kann. Beim
assemblieren werden dieses Label in konkrete Adressen übersetzt.

