%Register
%Adressierung
\section{Architektur}
X86-Assembler umfasst eine Instruktionsmenge die ursprünglich für Intels 8086 CPU konzipiert war. Diese basiert auf einer "von Neumann"-Architektur. Hier wird, im Gegensatz zur Harvard-Architektur, für Daten und Programme der gleiche Speicher verwendet. Es existierte ein fester Registersatz von 16 Registern der sich im Laufe der Zeit immer weiter vergrößert hat. Ursprünglich hatte x86 vier general-purpose Register (AX, BX, CX und DX), vier Segmentierungsregister zur Speicheradressierung (CS, DS, ES und SS), sowie FLAG-Registern und dem Instruktionszeiger-Register.

\subsection{Prozessor-Register}

Register der Intelprozessoren im \emph{Real Mode} (16 Bit)



\subsubsection{Allzweckregister}

\begin{tabular}{|c|l|l|}
\hline AX & \emph{accumulator} & AH, AL
\\
\hline BX & \emph{base register} & BH, BL
\\
\hline CX & \emph{counter register} & CH, CL
\\
\hline DX & \emph{data register} & DH, DL
\\
\hline \end{tabular}

Auch Rechenregister

16 Bit Breite – ein Prozessor \emph{word}

können jeweils als zwei 8-Bit-breite Register angesprochen werden (z.b.                                                                                                                  AH, AL).

Manipulation der Daten mit denen der Prozessor rechnet

erfüllen spezielle Aufgaben

Rechenoperationen können aber auf alle vier Register angewendet werden

AX erhält meist den Rückgabewert bei Funktionsaufrufen



\subsubsection{Segmentregister und Adressierung}

\begin{tabular}{|c|c|}
\hline CS & Codesegment \\
\hline DS & Datensegment \\
\hline ES & Extrasegment\\
\hline SS & Stacksegment \\
\hline
\end{tabular}

Die Segmentregister nehmen Anfangsadressen von Segmenten im Speicher auf.

16 Bit breit, lassen sich nicht in aufteilen

lassen sich lediglich auslesen und beschreiben

relevant für segmentierte adressierung im \emph{Real Mode} um über statt 16 Bit
zur Adressierung, 20 Bit zu verfügen

$Adresse = 16 * Segement + Offset$

Dies erhöht den Adressraum von 64 KByte auf 1 MByte.



\subsubsection{Zeige- und Indexregister}

\begin{tabular}{|c|l|}
\hline SI & \emph{source index} \\
\hline DI & \emph{destination index} \\
\hline
\end{tabular}

Nützlich als Zeiger auf Datenstrukturen

z.B. String-Manipulation


\begin{tabular}{|c|l|}
\hline SP & \emph{stack pointer}\\
\hline BP & \emph{base pointer} \\
\hline
\end{tabular}

Zeiger für den Stack

SP und BP dienen zum Aufspannen eines Stackframes bei Funktionsaufrufen

SP zeigt auf den aktuellen \emph{top}

BP zeigt auf den \emph{bottom}

\begin{tabular}{|c|l|}
\hline IP & \emph{instruction pointer} \\
\hline
\end{tabular}

Zeiger auf den nächsten Befehl in der Ausführung

wird ausschließlich intern durch den Prozessor verändert.

\subsubsection{Statusregister}

Ein 16 Bit Flag-Register F

{\small 15}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline & & & & O & D & I & T & S & Z & & A & & P & & C \\
\hline
\end{tabular}
{\small 0}

\emph{overflow, direction, interrupt, trap, sign, zero, auxiliary, parity}
und \emph{carry flag} 

nehmen bestimmte Belegung nach verschiedenen Operationen ein

beinflussen bestimmte Entscheidungen wie z.B. bedingte Sprünge (\emph{zero flag})



\subsection{Protected Mode}
Im \emph{protected mode} mit 32-Bit Addressierung werden alle 16-Bit auf 32-Bit erweitert

Diese werden mit dem Prefix E versehen: EAX, EBX, ..., ESP, EBP, ... EIP, etc.

\texttt{SEGMENT:OFFSET} Adressierung entfällt, da nun volle $2^{32}$-Bit (4 GByte) addressiert
werden können



\subsection{Adressraum}

Arten der Adressierung:

\begin{enumerate}
\item Direktwertadressierung (Immediates)
\item Direkte Adressierung
\item Indirekte Registeradressierung
\item Indizierte Resiteradressierung
\end{enumerate}


% \section{Unterprogramme}
