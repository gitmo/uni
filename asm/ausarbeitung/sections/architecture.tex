%Register
%Adressierung
\section{Architektur}
X86-Assembler umfasst eine Instruktionsmenge die ursprünglich für Intels 8086 CPU konzipiert war. Diese basiert auf einer "von Neumann"-Architektur. Hier wird, im Gegensatz zur Harvard-Architektur, für Daten und Programme der gleiche Speicher verwendet. Es existierte ein fester Registersatz von 16 Registern der sich im Laufe der Zeit immer weiter vergrößert hat. Ursprünglich hatte x86 vier general-purpose Register (AX, BX, CX und DX), vier Segmentregister zur Speicheradressierung (CS, DS, ES und SS), vier Indexregistern (SP, BP, SI, DI), sowie dem FLAG-Register und dem Instruktionszeiger-Register.

\subsection{Prozessor-Register}

Der Registersatz wurde im Laufe der Zeit mit jeder neuen Prozessorgenerationen erweitert. Wichtigster Schritt war dabei die Einführung von 32-Bit Registern mit dem 80386. Alle 16-bit Grundregister mit Ausnahme der Segmentregister wurden in ihrer Größe verdoppelt und mit dem Präfix E versehen. Mit der Einführung von 32-Bit Registern, Adressbus und Instruktionen spricht man auch von der IA-32 Plattform (\emph{Intel Architecture, 32-bit)}.

\subsubsection{Allzweckregister}

\begin{tabular}{|c|l|l|}
\hline EAX & \emph{accumulator} & AX, AH, AL \\
\hline EBX & \emph{base register} & BX, BH, BL \\
\hline ECX & \emph{counter register} & BX, CH, CL \\
\hline EDX & \emph{data register} & DX, DH, DL \\
\hline \end{tabular}

Die vier Allzweckregister, \emph{general-purpose} oder auch Rechenregister dienen als Operanden für vielerlei Instruktionen und ermöglichen eine freie Manipulation der Daten mit denen der Prozessor rechnet.

Sie besitzen seit dem 80386 eine Größe von 32-bit – in der Intel-Sprache ein DWord (\emph{double-word}, wird so bezeichnet da ein Prozessorwort ursprünglich aus 16-bit beinhalten konnte). Die alten Bezeichner {\tt AX, BX, CX} und {\tt DX} können nach wie vor verwendet werden und meinen dann die unteren 16-Bit des Registers.

Darüber hinaus war es beim 8086 möglich die Allzweckregister in zwei Teilen anzusprechen: dem \emph{High-Byte} für Bits 8-15 in {\tt AH, BH, CH} für  und {\tt DH} und dem \emph{Low-Byte} mit Bits 0-7 in {\tt AL, BL, CL} und {\tt DL}. Eine Operation auf einen dieser 8-bit Hälften geschieht ohne Seiteneffekte auf jeweils andere.

Obwohl fast alle Rechenoperationen auf alle vier Register angewendet werden können, erfüllen sie für manche Instruktionen spezielle Aufgaben. Genaue Angaben findet der Programmierer dazu zum Beispiel in Intels Referenz-Dokumentation. \cite{intelreferenz}

Ein Compiler legt über seine Aufrufkonvention oft fest ob den Registern besondere Aufgaben zukommen sollen. So wird {\tt EAX} von vielen C-Compilern immer als Register für den Rückgabewert eines Funktionsaufrufs benutzt. \cite{wp:callconv}

\subsubsection{Segmentregister und Adressierung}

\begin{tabular}{|c|l|}
\hline CS & \emph{code segment} \\
\hline DS & \emph{daten segment} \\
\hline SS & \emph{stack segment} \\
\hline ES, FS, GS & \emph {extra segment registers} \\
\hline
\end{tabular}

Die Segmentregister sind als einzige Register 16-Bit breit geblieben und lassen sich nicht in byteweise aufteilen. Das hängt mit ihrer speziellen Funktion zusammen, denn sie nehmen Anfangsadressen von Segmenten im Speicher auf. Dies ist nützlich zur Bildung von Pointern. Die Adresse des Stack-Speichers wird so zum Beispiel über das Registerpaar SS:ESP ermittelt. Vor dem 80386 Prozessor waren sie besonders relevant für die sogenannte segmentierte Adressierung im \emph{Real Mode} um die vollen 20-Bit des Adressbusses bei nur 16-Bit Registerbreite bei der Adressierung verwenden zu können.
Segmentregister können immer nur mittels eines Allzweckregisters oder spezielle Instruktionen gesetzt werden.

% lassen sich lediglich auslesen und beschreiben

\subsubsection{Zeige- und Indexregister}

Diese Register sind nützlich als Zeiger auf Datenstrukturen, Indexierung in Arrays und bei String-Manipulation und als Offset als Teil einer Adresse. Sie lassen sich mit den Segmentregistern kombinieren, um in weit entfernte Speicherbereiche zu zeigen. 

\begin{tabular}{|c|l|l|}
\hline ESI & \emph{source index} & DS:ESI, SI\\
\hline EDI & \emph{destination index} & ES:EDI, DI\\
\hline
\end{tabular}

ESI und EDI dienen als String und Speicherkopieroperationen in Arrays und lassen sich mit DS bzw. DS kombinieren.

\begin{tabular}{|c|l|}
\hline ESP & \emph{stack pointer} SS\\
\hline EBP & \emph{base pointer} SS\\
\hline
\end{tabular}

Die Zeiger für den Stack {\tt ESP} und {\tt EBP} dienen zum Aufspannen eines Stackbereich bei Funktionsaufrufen. {\tt ESP} zeigt dabei immer auf das oberste Element im Stack und wird bei {\tt push}- und {\tt pop}-Befehlen manipuliert, während {\tt EBP} auf eine anderen Adresse im Stack zeigen kann um die Basis eines Stackbereichs zu definieren. Das Stack-Segmentregister SS definiert das aktuelle Speichersegment für die Offsets in {\tt ESP} und {\tt EBP}.

\begin{tabular}{|c|l|}
\hline EIP & \emph{instruction pointer} \\
\hline
\end{tabular}

Der Instruktionszeiger ist ein spezielles Register und zeigt immer auf den aktuell nächsten Befehl in der Ausführung. Der {\tt EIP} wird ausschließlich intern durch den Prozessor verändert – der Programmieren manipuliert diesen indirekt über bedingte und unbedingte Sprungbefehle. Bei Unterfunktionsaufrufen wird der aktuelle {\tt EIP}, der  auf die nächste Instruktion hinter {\tt call} zeigt, automatisch auf den Stack gelegt und bei der Rückkehr mittels {\tt ret} an diese Adresse zurückverzweigt.

\subsubsection{Statusregister}

Das Register {\tt EFLAGS} enthält Informationen über den aktuellen Zustand des Prozessors in Form von binären Flags. Die unteren 16-Bits (ursprünglich das 8086-Register {\tt FLAGS}) haben untenstehende Bedeutung. Die 32-Bit des {\tt EFLAGS} erhält noch einige zusätzliche Flags.

{\small 15}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline & & & & O & D & I & T & S & Z & & A & & P & & C \\
\hline
\end{tabular}
{\small 0}

\emph{overflow, direction, interrupt, trap, sign, zero, auxiliary, parity}
und \emph{carry flag} 

\subsection{Adressraum}

\subsubsection{Real Mode}

16 bit Mode, seit 8086

Segmentregister (CS, DS, SS, ES) sind relevant für segmentierte Adressierung im
\emph{Real Mode} um über statt 16 Bit zur Adressierung, 20 Bit zu verfügen

$Adresse = 16 * Segment + Offset$

Dies erhöht den Adressraum von 64 KByte auf 1 MByte.


\subsubsection{Protected Mode}
Im \emph{protected mode} mit 32-Bit Adressierung werden alle 16-Bit auf 32-Bit erweitert

\texttt{SEGMENT:OFFSET} Adressierung ist ebenfalls möglich, aber weniger relevant als im
\emph{Real Mode}, da nun volle $2^{32}$-Bit (4 GByte) adressiert werden können




Arten der Adressierung:

\begin{enumerate}
\item Direktwertadressierung (Immediates)
\item Direkte Adressierung
\item Indirekte Registeradressierung
\item Indizierte Registeradressierung
\end{enumerate}


% \section{Unterprogramme}
